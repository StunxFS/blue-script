// Copyright (C) 2024 Jose Mendoza. All rights reserved. Use of this
// source code is governed by an MIT license that can be found in the
// LICENSE file.

%import common.CPP_COMMENT
%import common.C_COMMENT
%import common.NUMBER
%import common.CNAME -> NAME
%import common.ESCAPED_STRING -> STRING
%import common.WS

%ignore CPP_COMMENT
%ignore C_COMMENT
%ignore WS

?module: extern_pkg* decl*

// Declarations

?decl: access_modifier? (use_decl
       | mod_decl
       | var_decl
       | const_decl
       | extern_decl
       | class_decl
       | fn_decl)

extern_pkg: KW_EXTERN KW_PKG NAME [KW_AS NAME]

use_decl: KW_USE use_tree
use_tree: simple_path DOUBLE_COLON MUL
       | simple_path DOUBLE_COLON LBRACE [use_tree (COMMA use_tree)*] RBRACE
       | simple_path [KW_AS NAME]

mod_decl: KW_MOD NAME [LBRACE decl* RBRACE]

var_decl: KW_VAR NAME [COLON type] OP_DECL expr
const_decl: KW_CONST NAME [COLON type] OP_DECL expr

extern_decl: KW_EXTERN decl

class_decl: KW_CLASS NAME LBRACE (class_field | decl)* RBRACE
class_field: access_modifier? NAME COLON type [OP_DECL expr]

fn_decl: KW_FN NAME LPAREN fn_args? RPAREN [BANG | type] fn_body?
fn_args: (KW_SELF | fn_arg) (COMMA fn_arg)*
fn_arg: NAME COLON type [OP_DECL expr]
fn_body: LBRACE stmt* RBRACE

access_modifier: KW_PUB | KW_PROT

?type: primitive_type
       | NAME (DOT NAME)* -> user_type
       | QUESTION type -> option_type
       | LBRACKET expr? RBRACKET type -> array_type
       | LBRACE type COLON type RBRACE -> map_type
       | type PIPE type (PIPE type)* -> sum_type
       | LPAREN type COMMA type (COMMA type)* RPAREN -> tuple_type

// TODO: do we implement thread as a generic type? `thread[T]` or "thread"
primitive_type: "any"
       | "bool"
       | "number"
       | "string"

// Statements

?stmt: expr
       | assignment
       | block
       | KW_WHILE LPAREN expr RPAREN stmt -> while_stmt

block: LBRACE stmt* RBRACE
assignment: expr (COMMA expr)* op_assign expr
op_assign: OP_DECL
       | OP_ASSIGN
       | OP_PLUS_ASSIGN
       | OP_MINUS_ASSIGN
       | OP_DIV_ASSIGN
       | OP_MUL_ASSIGN
       | OP_MOD_ASSIGN
       | OP_BIT_AND_ASSIGN
       | OP_BIT_OR_ASSIGN
       | OP_BIT_XOR_ASSIGN

// Expressions

?expr: and_expr
and_expr: or_expr (LOGICAL_OR or_expr)*
or_expr: compare_expr (LOGICAL_AND compare_expr)*
compare_expr: bitwise_expr (compare_op bitwise_expr)?
bitwise_expr: bitshift_expr (bitwise_op bitshift_expr)*
bitshift_expr: addition_expr (bitshift_op addition_expr)*
addition_expr: multiply_expr (addition_op multiply_expr)*
multiply_expr: unary_expr (multiply_op unary_expr)*
unary_expr: unary_op* primary_expr
?primary_expr: literal
       | AT NAME -> builtin_var
       | expr DOT NAME -> selector_expr
       | simple_path
       | LBRACKET [expr (COMMA expr)*] RBRACKET BANG? -> array_literal
       | LBRACE expr COLON expr (COMMA expr COLON expr)* RBRACE -> map_literal
       | LPAREN expr (COMMA expr)* RPAREN -> tuple_literal
       | expr LPAREN [expr (COMMA expr)*] RPAREN -> call_expr
       | if_expr
       | KW_SWITCH [LPAREN expr RPAREN] LBRACE switch_branches RBRACE -> switch_expr
       | par_expr

compare_op: LT | GT | LE | GE | EQ | NEQ
bitwise_op: BIT_AND | BIT_OR | BIT_XOR
bitshift_op: LSHIFT | RSHIFT
addition_op: PLUS | MINUS
multiply_op: MUL | DIV | MOD
unary_op: BANG | BIT_NOT | MINUS

par_expr: LPAREN expr RPAREN

simple_path: NAME (DOUBLE_COLON NAME)*

if_expr: if_header else_if_expr* else_stmt?
if_header: KW_IF LPAREN expr RPAREN stmt
else_if_expr: KW_ELSE KW_IF LPAREN expr RPAREN stmt
else_stmt: KW_ELSE stmt

switch_branches: switch_branch (COMMA switch_branch)*
switch_branch: expr (COMMA expr)* ARROW stmt
       | KW_ELSE ARROW stmt

?literal: KW_NIL
       | bool_lit
       | number_lit
       | STRING
       | KW_SELF
       | NAME
bool_lit: KW_TRUE | KW_FALSE
number_lit: NUMBER | BIN_NUMBER | OCT_NUMBER | HEX_NUMBER

// Tokens

BIN_NUMBER: /0b?[0-1]*l?/
OCT_NUMBER: /0o?[0-7]*l?/ii
HEX_NUMBER: /0x[\da-f]*l?/i

PLUS: "+"
MINUS: "-"
MUL: "*"
DIV: "/"
MOD: "%"
AT: "@"
SLASH: "/"
ARROW: "->"
COMMA: ","
DOT: "."
DOUBLE_COLON: "::"
COLON: ":"
BANG: "!"
QUESTION: "?"
PIPE: "|"
LSHIFT: "<<"
RSHIFT: ">>"
EQ: "=="
NEQ: "!="
LT: "<"
GT: ">"
LE: "<="
GE: ">="
LOGICAL_OR: "||"
LOGICAL_AND: "&&"
BIT_AND: "&"
BIT_OR: "|"
BIT_XOR: "^"
BIT_NOT: "~"

LPAREN: "("
RPAREN: ")"
LBRACE: "{"
RBRACE: "}"
LBRACKET: "["
RBRACKET: "]"

OP_DECL: ":="
OP_ASSIGN: "="
OP_PLUS_ASSIGN: "+="
OP_MINUS_ASSIGN: "-="
OP_DIV_ASSIGN: "/="
OP_MUL_ASSIGN: "*="
OP_MOD_ASSIGN: "%="
OP_BIT_AND_ASSIGN: "&="
OP_BIT_OR_ASSIGN: "|="
OP_BIT_XOR_ASSIGN: "^="

KW_AS: "as"
KW_CLASS: "class"
KW_CONST: "const"
KW_ELSE: "else"
KW_EXTERN: "extern"
KW_FALSE: "false"
KW_FN: "fn"
KW_IF: "if"
KW_MOD: "mod"
KW_NIL: "nil"
KW_PKG: "pkg"
KW_PROT: "prot"
KW_PUB: "pub"
KW_SELF: "self"
KW_SWITCH: "switch"
KW_TRUE: "true"
KW_USE: "use"
KW_VAR: "var"
KW_WHILE: "while"

