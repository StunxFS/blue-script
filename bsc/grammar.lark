// Copyright (C) 2024 Jose Mendoza. All rights reserved. Use of this
// source code is governed by an MIT license that can be found in the
// LICENSE file.

%import common.CPP_COMMENT
%import common.C_COMMENT
%import common.NUMBER
%import common.CNAME -> NAME
%import common.ESCAPED_STRING -> STRING
%import common.WS

%ignore CPP_COMMENT
%ignore C_COMMENT
%ignore WS

module: extern_pkg* decl*

// Declarations

?decl: use_decl
       | mod_decl
       | var_decl
       | const_decl
       | enum_decl
       | class_decl
       | fn_decl

extern_pkg: KW_EXTERN KW_PKG NAME [KW_AS NAME]

use_decl: [access_modifier] KW_USE use_tree
use_tree: path_expr DOUBLE_COLON MUL
       | path_expr DOUBLE_COLON LBRACE [use_tree (COMMA use_tree)*] RBRACE
       | path_expr [KW_AS NAME]

mod_decl: [access_modifier] KW_MOD NAME [LBRACE decl* RBRACE]

var_decl: [access_modifier] KW_VAR var_ident (COMMA var_ident)* OP_ASSIGN expr
var_ident: NAME [COLON type]

const_decl: [access_modifier] KW_CONST NAME [COLON type] OP_ASSIGN expr

enum_decl: [access_modifier] KW_ENUM NAME LBRACE enum_field* decl* RBRACE
enum_field: NAME [OP_ASSIGN expr]

class_decl: [access_modifier] KW_CLASS NAME LBRACE (class_field | decl)* RBRACE
class_field: [access_modifier] NAME COLON type [OP_ASSIGN expr]

fn_decl: [access_modifier] KW_FN NAME LPAREN [fn_args] RPAREN [BANG | type] [block]
fn_args: (KW_SELF | fn_arg) (COMMA fn_arg)*
fn_arg: NAME COLON type [OP_ASSIGN expr]

access_modifier: KW_PUB [LPAREN KW_PKG RPAREN] | KW_PROT

?type: primitive_type
       | NAME (DOT NAME)* -> user_type
       | QUESTION type -> option_type
       | LBRACKET expr? RBRACKET type -> array_type
       | LBRACE type COLON type RBRACE -> map_type
       | type PIPE type (PIPE type)* -> sum_type
       | LPAREN type COMMA type (COMMA type)* RPAREN -> tuple_type

// TODO: do we implement thread as a generic type? `thread[T]` or "thread"
primitive_type: "any"
       | "bool"
       | "number"
       | "string"

// Statements

?stmt: expr
       | var_decl
       | const_decl
       | assignment
       | block_stmt
       | KW_WHILE expr block -> while_stmt

block: LBRACE stmt* RBRACE // returns array of stmts in AstGen
block_stmt: LBRACE stmt* RBRACE // returns BlockStmt in AstGen

assignment: expr (COMMA expr)* op_assign expr
op_assign: OP_ASSIGN
       | OP_ASSIGN
       | OP_PLUS_ASSIGN
       | OP_MINUS_ASSIGN
       | OP_DIV_ASSIGN
       | OP_MUL_ASSIGN
       | OP_MOD_ASSIGN
       | OP_BIT_AND_ASSIGN
       | OP_BIT_OR_ASSIGN
       | OP_BIT_XOR_ASSIGN

// Expressions

?expr: and_expr
and_expr: or_expr (LOGICAL_OR or_expr)*
or_expr: compare_expr (LOGICAL_AND compare_expr)*
compare_expr: bitwise_expr (compare_op bitwise_expr)?
bitwise_expr: bitshift_expr (bitwise_op bitshift_expr)*
bitshift_expr: addition_expr (bitshift_op addition_expr)*
addition_expr: multiply_expr (addition_op multiply_expr)*
multiply_expr: unary_expr (multiply_op unary_expr)*
unary_expr: unary_op* primary_expr
?primary_expr: literal
       | par_expr
       | AT NAME -> builtin_var
       | expr DOT NAME -> selector_expr
       | path_expr
       | DOT NAME -> enum_literal
       | LBRACKET [expr (COMMA expr)*] RBRACKET BANG? -> array_literal
       | LBRACE expr COLON expr (COMMA expr COLON expr)* RBRACE -> map_literal
       | LPAREN expr (COMMA expr)* RPAREN -> tuple_literal
       | expr LPAREN [expr (COMMA expr)*] RPAREN -> call_expr
       | if_expr
       | match_expr

compare_op: LT | GT | LE | GE | EQ | NEQ
bitwise_op: BIT_AND | BIT_OR | BIT_XOR
bitshift_op: LSHIFT | RSHIFT
addition_op: PLUS | MINUS
multiply_op: MUL | DIV | MOD
unary_op: BANG | BIT_NOT | MINUS

par_expr: LPAREN expr RPAREN

path_expr: NAME (DOUBLE_COLON NAME)*

if_expr: if_header else_if_expr* else_stmt?
if_header: KW_IF expr block
else_if_expr: KW_ELSE KW_IF expr block
else_stmt: KW_ELSE block

match_expr: KW_MATCH [expr] LBRACE match_branches RBRACE
match_branches: match_branch (COMMA match_branch)*
match_branch: expr (COMMA expr)* ARROW stmt
       | KW_ELSE ARROW stmt

?literal: KW_NIL
       | bool_lit
       | number_lit
       | STRING
       | KW_SELF
       | NAME
bool_lit: KW_TRUE | KW_FALSE
number_lit: BIN_NUMBER | OCT_NUMBER | HEX_NUMBER | NUMBER

// Tokens

BIN_NUMBER.2: /0b[0-1]*l?/i
OCT_NUMBER.2: /0o[0-7]*l?/i
HEX_NUMBER.2: /0x[\da-f]*l?/i

PLUS: "+"
MINUS: "-"
MUL: "*"
DIV: "/"
MOD: "%"
AT: "@"
SLASH: "/"
ARROW: "=>"
COMMA: ","
DOT: "."
DOUBLE_COLON: "::"
COLON: ":"
BANG: "!"
QUESTION: "?"
PIPE: "|"
LSHIFT: "<<"
RSHIFT: ">>"
EQ: "=="
NEQ: "!="
LT: "<"
GT: ">"
LE: "<="
GE: ">="
LOGICAL_OR: "||"
LOGICAL_AND: "&&"
BIT_AND: "&"
BIT_OR: "|"
BIT_XOR: "^"
BIT_NOT: "~"

LPAREN: "("
RPAREN: ")"
LBRACE: "{"
RBRACE: "}"
LBRACKET: "["
RBRACKET: "]"

OP_ASSIGN: "="
OP_PLUS_ASSIGN: "+="
OP_MINUS_ASSIGN: "-="
OP_DIV_ASSIGN: "/="
OP_MUL_ASSIGN: "*="
OP_MOD_ASSIGN: "%="
OP_BIT_AND_ASSIGN: "&="
OP_BIT_OR_ASSIGN: "|="
OP_BIT_XOR_ASSIGN: "^="

KW_AS.1: "as"
KW_CLASS.1: "class"
KW_CONST.1: "const"
KW_ELSE.1: "else"
KW_ENUM.1: "enum"
KW_EXTERN.1: "extern"
KW_FALSE.1: "false"
KW_FN.1: "fn"
KW_IF.1: "if"
KW_MATCH.1: "match"
KW_MOD.1: "mod"
KW_NIL.1: "nil"
KW_PKG.1: "pkg"
KW_PROT.1: "prot"
KW_PUB.1: "pub"
KW_SELF.1: "self"
KW_TRUE.1: "true"
KW_USE.1: "use"
KW_VAR.1: "var"
KW_WHILE.1: "while"

